## Уровень 1
1. Какие три операции лежат в основе алгоритма разделяй и властвуй?
2. В чем преимущества и недостатки алгоритма разделяй и властвуй?
3. Опишите алгоритм бинарного поиска словами или псевдокодом
4. Какова сложность бинарного поиска?
5. Попробуйте написать алгоритм бинарного поиска (мы в классе уже делали реализацию - попробуйте написать сами, а после посмотрите одно из решений - [решение](../lesson4/BinarySearch.java))
6. Даны два целых числа x и n, напишите функцию для вычисления x^n
   - Задачу можно решать рекурсивно x^n = `x*x*x*x`{n раз} - сложность алгоритма O(n)
   - Задачу можно оптимизировать и решить за O(log(n)) - идея решения в том чтобы уменьшить количество умножений - идея решения - чистая математика 
   Попробуйте расписать несколько вариантов (так проще понять решение):
     `x^4 = (x^2)^2` - то есть можно вызывать рекурсию не на всем числе, а на квадрате числа (исключение нечетная степень)
   Если сложно понять решение с оптимизацией - рассмотрим оптимальное решение задачи на занятии
7.  Имея два отсортированных массива размера m и n соответственно, вам нужно найти элемент, который будет находиться на k-й позиции в конечном отсортированном массиве.
    Массив 1 - 100 112 256 349 770
    Массив 2 - 72 86 113 119 265 445 892
    к = 7
    Вывод : 256
    Окончательный отсортированный массив -
    72, 86, 100, 112, 113, 119, 256, 265, 349, 445, 770, 892
    7-й элемент этого массива равен 256.
Идея решения никак не относится к алгоритму разделяй и властвуй - это лишь подготовительный этап для алгоритмов сортировки. Есть несколько возможных решений 
- Соединить 2 массива в 1, отсортировать и найти значение на позиции k - сложность решения зависит от алгоритма сортировки
- Применить более хитрый метод - объявить 3 переменные i1 (для прохода по первому массиву), i2 (для прохода по второму массиву) и res - счетчик для подсчета текущего элемента, 
 сравнивать по 1 элементу и если элемент в первом массиве меньше второго, то увеличивать i1, иначе увеличивать i2
## Уровень 2
1. Попробуйте реализовать алгоритм QuickSort (если не получится ничего страшного)
   Алгоритм быстрой сортировки является рекурсивным, метод на вход будет принимать границы участка массива от l включительно и до r не включительно. Работает следующим образом:

Процедура partition.
   a. Выбирается pivot элемент
   b. переставляются элементы участка массива таким образом, чтобы массив разбился на 2 части: левая часть
   содержит элементы, которые меньше pivot, а правая часть содержит элементы, которые больше или равны pivot.
Повторяется алгоритм на левой и правой частях

   - Для начала попробуйте реализовать метод partition
   - После уже реализуйте сам алгоритм
Псевдокод: 
```agsl
int partition(array[n], int left, int right)
     int pivot = a[(left + right) / 2]// выбираем пайвот например взяв средний элемент
     int leftPointer = left
     int rightPointer = right
     while (leftPointer <= rightPointer) 
        while (a[i] < pivot)
           leftPointer++
        while (a[j] > pivot)
           rightPointer--
        if (leftPointer >= rightPointer) 
           break
        swap(a[leftPointer++], a[rightPointer--])
     return rightPointer
     
 ```

```
  
  
  void quicksort(array[], int left, int right)
     if left < r
        int median = partition(array, left, right)
        quicksort(array, left, median)
        quicksort(array, median + 1, right)
```
